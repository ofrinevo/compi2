package slp;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Collections;

parser code
{:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;

	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public int getLine() {
		return lexer.getLineNumber();
	}

    public int getColumn() {
    		return lexer.getColumnNumber();
    	}
	
	public void syntax_error(Symbol s) {
		expected_token_ids();
		expected_token_ids();
		expected_token_ids();
		List<Integer> expectedIds = expected_token_ids();
		String expectedString = "";
		boolean first = true;
		List<String> list = new LinkedList<String>();
		for (Integer symbol:expectedIds) {
			String str = Helper.map.get(symbol.intValue());
			list.add(str);
		}
		Collections.sort(list);
		for (String str:list) {
		if (first) {
			expectedString += "'" + str + "'";
			first = false;
		} else
			expectedString += " or '" + str + "'";
		}
		Token tok = (Token) s;
		System.err.println(tok.getLine() + ":" + tok.getColumn() + " : syntax error; expected " + expectedString + ", but found '" + tok.getValue() + "'");
	}
:};

//scan with {:
//	Token t = (Token)getScanner().next_token();
//	System.out.println(t.getLine() + ":type: " + t.getTagAsString() + " , value: " + t.getValue());
//	return t; 
//:};
////////////////////////////////////
// terminals //
terminal String CLASS_ID, ID;
terminal SEMICOLON, CLASS, STATIC, VOID, INT, BOOLEAN, STRING_RESERVED;
terminal LCBR, RCBR, LPAREN, RPAREN, LB, RB, COMMA;
terminal String INTEGER;
terminal String STRING;
terminal EXTENDS, RETURN, IF, ELSE, WHILE, BREAK, CONTINUE, THIS, NEW, LENGTH, TRUE, FALSE, NULL;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, MOD, LAND, LOR, LTE, LT, GTE, GT, EQUAL, NEQUAL, LNEG;
terminal DOT;
terminal ASSIGN;
terminal UMINUS; //only for precedence issues
//////////////////////////

////////////////////////////////////////////
// nonterminals //

// "super" nonterminals (defind by the CFG)

nonterminal Program program;
nonterminal ICClass classDecl;
nonterminal List<Field> field;
nonterminal Method method;
nonterminal List<Formal> formals;
nonterminal Type type;
nonterminal Statement stmt;
nonterminal Location location;
nonterminal Expression expr;
nonterminal Call call;
nonterminal StaticCall staticCall;
nonterminal VirtualCall virtualCall;
nonterminal Literal literal;

// "building blocks" nonterminals for "super" nonterminals
// naming convention: classname+super_nonterminal_name

// location
nonterminal ArrayLocation arrayLocationLocation;
nonterminal VariableLocation variableLocationLocation;

// stmt
nonterminal Assignment assignmentStmt;
nonterminal Break breakStmt;
//nonterminal CallStatement callStatementStmt;
nonterminal Continue continueStmt;
nonterminal If ifStmt;
nonterminal LocalVariable localVariableStmt;
nonterminal Return returnStmt;
nonterminal StatementsBlock statementsBlockStmt;
nonterminal While whileStmt;

// expr
nonterminal ExpressionBlock expressionBlockExpr;
nonterminal Length lengthExpr;
nonterminal Literal literalExpr;
nonterminal This thisExpr;
nonterminal BinaryOp binaryOpExpr;
nonterminal UnaryOp unaryOpExpr;

// method
//nonterminal StaticMethod staticMethodMethod;
//nonterminal VirtualMethod virtualMethodMethod;

// binaryOp
nonterminal LogicalBinaryOp logicalBinaryOpBinop;
nonterminal MathBinaryOp mathBinaryOpBinop;

//binop
nonterminal BinaryOps mathBinop;
nonterminal BinaryOps logicalBinop;

// unaryOp
nonterminal LogicalUnaryOp logicalUnaryOpUnop;
nonterminal MathUnaryOp mathUnaryOpUnop;

// unop
nonterminal UnaryOps mathUnop;
nonterminal UnaryOps logicalUnop;

// type
//nonterminal Type typeOrVoid;
//nonterminal PrimitiveType primitiveTypeType;
//nonterminal UserType userTypeType;

// building blocks nonterminals of building blocks nonterminals
// naming convention: classname+super_nonterminal_name

// newExpr
nonterminal NewArray newArrayNewExpr;
nonterminal NewClass newClassNewExpr;

// custom rules for help with kleene star

nonterminal List<List> fieldOrMethodKS;
nonterminal List<String> idList;
nonterminal List<Statement> stmtKS;
nonterminal List<Expression> exprKS;
nonterminal List<ICClass> classDeclKS;

// Precedence declarations

// TODO: not sure if parentheses are for all with the precedence or only for method calls etc page 8 in pdf

precedence left ASSIGN;
precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left LTE, LT, GTE, GT;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence right LNEG, UMINUS;
precedence left CLASS_ID, ID,INTEGER, STRING, SEMICOLON, CLASS, EXTENDS, STATIC, VOID, INT, BOOLEAN, STRING_RESERVED, RETURN, IF, ELSE, WHILE, BREAK, CONTINUE, THIS, NEW, LENGTH, TRUE, FALSE, NULL, COMMA;
precedence left LPAREN, RPAREN, LB, RB, LCBR, RCBR, DOT;

//////////////
start with program;
// The grammar

program ::= classDeclKS:cl
		{: RESULT = new Program(cl); :}
;
classDeclKS ::= classDecl:c
			{: List<ICClass> cl = new LinkedList<ICClass>(); cl.add(c); RESULT = cl; :}
			| classDeclKS:cl classDecl:c
			{: cl.add(c); RESULT = cl; :}
			|
			{: RESULT = new LinkedList<ICClass>(); :}
;
classDecl ::= CLASS CLASS_ID:cid EXTENDS CLASS_ID:eid LCBR fieldOrMethodKS:fmKS RCBR
			{: RESULT = new ICClass(cidleft, cid, eid, (List<Field>)(List<?>)(fmKS.get(1)), (List<Method>)(List<?>)(fmKS.get(0))); :}
			| CLASS CLASS_ID:cid LCBR fieldOrMethodKS:fmKS RCBR
			{: RESULT = new ICClass(cidleft, cid, (List<Field>)(List<?>)(fmKS.get(1)), (List<Method>)(List<?>)(fmKS.get(0))); :}
;
fieldOrMethodKS ::= field:f
				{: List<List> foml = new ArrayList<List>(); List<Method> ml = new LinkedList<Method>(); List<Field> fl = new LinkedList<Field>(); foml.add(ml); fl.addAll(f); foml.add(fl); RESULT = foml; :}
				| method:m
				{: List<List> foml = new ArrayList<List>(); List<Method> ml = new LinkedList<Method>(); List<Field> fl = new LinkedList<Field>(); ml.add(m); foml.add(ml); foml.add(fl); RESULT = foml; :}
				| fieldOrMethodKS:l field:f
				{: ((List<Field>)l.get(1)).addAll(f); RESULT = l; :}
				| fieldOrMethodKS:l method:m
				{: ((List<Method>)l.get(0)).add(m); RESULT = l; :}
				|
				{: List<List> foml = new ArrayList<List>(); List<Method> ml = new LinkedList<Method>(); List<Field> fl = new LinkedList<Field>(); foml.add(ml); foml.add(fl); RESULT = foml; :}		
;
//typeOrVoid ::= VOID
//            {: RESULT = new PrimitiveType(getLine() ,DataTypes.VOID); :}
//            | type:t
//            {: RESULT = t; :}
//;
type ::= INT:i
        {: RESULT = new PrimitiveType(getLine() ,DataTypes.INT); :}
        | BOOLEAN:bool
        {: RESULT = new PrimitiveType(getLine() ,DataTypes.BOOLEAN); :}
        | STRING_RESERVED:str
        {: RESULT = new PrimitiveType(getLine() ,DataTypes.STRING); :}
        | CLASS_ID:classtype
        {: RESULT = new UserType(getLine(), classtype); :}
        | type:t LB RB
        {: t.incrementDimension(); RESULT = t; :}
;			
field ::= type:pt idList:idl SEMICOLON
		{: List<Field> fl = new LinkedList<Field>(); for (String id : idl) {fl.add(new Field(pt, id));} RESULT = fl; :}
;
idList ::= ID:id
		{: List<String> idl = new LinkedList<String>(); idl.add(id); RESULT = idl; :}
		| idList:idl COMMA ID:id
		{: idl.add(id); RESULT = idl; :}
;

method ::= STATIC type:t ID:id LPAREN formals:f RPAREN LCBR stmtKS:sl RCBR
		{: RESULT = new StaticMethod(t, id, f, sl); :}
		| STATIC VOID ID:id LPAREN formals:f RPAREN LCBR stmtKS:sl RCBR
		{: RESULT = new StaticMethod(new PrimitiveType(idleft ,DataTypes.VOID), id, f, sl); :}
		| type:t ID:id LPAREN formals:f RPAREN LCBR stmtKS:sl RCBR
		{: RESULT = new VirtualMethod(t, id, f, sl); :}
		| VOID ID:id LPAREN formals:f RPAREN LCBR stmtKS:sl RCBR
		{: RESULT = new VirtualMethod(new PrimitiveType(idleft ,DataTypes.VOID), id, f, sl); :}
;
//method ::= staticMethodMethod:sm
//		{: RESULT = sm; :}
//		| virtualMethodMethod:vm
//		{: RESULT = vm; :}
//;
//staticMethodMethod ::= STATIC typeOrVoid:t ID:id LPAREN formals:f RPAREN LCBR stmtKS:sl RCBR
//					{: RESULT = new StaticMethod(t, id, f, sl); :}
//;
//virtualMethodMethod ::= typeOrVoid:t ID:id LPAREN formals:f RPAREN LCBR stmtKS:sl RCBR
//					{: RESULT = new VirtualMethod(t, id, f, sl); :}
//;
formals ::= type:pt ID:id
			{: List<Formal> fl = new LinkedList<Formal>(); fl.add(new Formal(pt, id)); RESULT = fl; :}
			| formals:fl COMMA type:pt ID:id
			{: fl.add(new Formal(pt, id)); RESULT = fl; :}
			|
			{: RESULT = new LinkedList<Formal>(); :}
;			
stmtKS ::= stmt:s
			{: List<Statement> sl = new LinkedList<Statement>(); sl.add(s); RESULT = sl; :}
			| stmtKS:sl stmt:s
			{: sl.add(s); RESULT = sl; :}
			|
			{: RESULT = new LinkedList<Statement>(); :}
;
stmt ::= assignmentStmt:as SEMICOLON
		{: RESULT = as; :}
		| call:c SEMICOLON
		{: RESULT = new CallStatement(c); :}
		| returnStmt:rs SEMICOLON
		{: RESULT = rs; :}
		| ifStmt:is
		{: RESULT = is; :}
		| whileStmt:ws
		{: RESULT = ws; :}
		| breakStmt:bs SEMICOLON
		{: RESULT = bs; :}
		| continueStmt:cs SEMICOLON
		{: RESULT = cs; :}
		| statementsBlockStmt:sb
		{: RESULT = sb; :}
		| localVariableStmt:ls SEMICOLON
		{: RESULT = ls; :}
;		
assignmentStmt ::= location:l ASSIGN expr:e
				{: RESULT = new Assignment(l,e); :}
;
breakStmt ::= BREAK:b
			{: RESULT = new Break(getLine()); :}
;
//callStatementStmt ::= call:c SEMICOLON
//					{: RESULT = new CallStatement(c); :}
//;
continueStmt ::= CONTINUE:c
					{: RESULT = new Continue(getLine()); :}
; 
ifStmt ::= IF LPAREN expr:e1 RPAREN stmt:s1 ELSE stmt:s2
		{: RESULT = new If(e1, s1, s2); :}
		| IF LPAREN expr:e1 RPAREN stmt:s1
		{: RESULT = new If(e1, s1); :}
;
localVariableStmt ::= type:t ID:id ASSIGN expr:e
					{: RESULT = new LocalVariable(t, id, e); :}
					| type:t ID:id
					{: RESULT = new LocalVariable(t, id); :}
;
returnStmt ::= RETURN:r expr:e
			{: RESULT = new Return(getLine(), e); :}
			| RETURN:r
			{: RESULT = new Return(getLine()); :}
;			
statementsBlockStmt ::= LCBR:lcp stmtKS:sl RCBR
					{: RESULT = new StatementsBlock(slleft, sl); :}
;
whileStmt ::= WHILE LPAREN expr:e RPAREN stmt:s
			{: RESULT = new While(e, s); :}	
;
expr ::= location:l
		{: RESULT = l; :}
		| call:c
		{: RESULT = c; :}
		| thisExpr:te
		{: RESULT = te; :}
		| newClassNewExpr:nce
		{: RESULT = nce; :}
		| newArrayNewExpr:nae
		{: RESULT = nae; :}
		| lengthExpr:le
		{: RESULT = le; :}
		| binaryOpExpr:bop
		{: RESULT = bop; :}
		| unaryOpExpr:uop
		{: RESULT = uop; :}
		| literalExpr:le
		{: RESULT = le; :}
		| expressionBlockExpr:eb
		{: RESULT = eb; :}
;		
location ::= variableLocationLocation:vl
			{: RESULT = vl; :}
			| arrayLocationLocation:al
			{: RESULT = al; :}
;
variableLocationLocation ::= expr:e DOT ID:id
							{: RESULT = new VariableLocation(getLine(), e, id); :}
							| ID:id
							{: RESULT = new VariableLocation(getLine(), id); :}
;
arrayLocationLocation ::= expr:e1 LB expr:e2 RB
							{: RESULT = new ArrayLocation(e1,e2); :}
;
call ::= staticCall:sc
		{: RESULT = sc; :}
		| virtualCall:vc
		{: RESULT = vc; :}
;
staticCall ::= CLASS_ID:cid DOT ID:id LPAREN exprKS:el RPAREN
			{: RESULT = new StaticCall(getLine(), cid, id, el); :}
;
virtualCall ::= ID:id LPAREN exprKS:el RPAREN
				{: RESULT = new VirtualCall(getLine(), id, el); :}
				| expr:e DOT ID:id LPAREN exprKS:el RPAREN
				{: RESULT = new VirtualCall(getLine(), e, id, el); :}
;
exprKS ::= expr:e
			{: List<Expression> el = new LinkedList<Expression>(); el.add(e); RESULT = el; :}
			| exprKS:el COMMA expr:e
			{: el.add(e); RESULT = el; :}
			|
			{: RESULT = new LinkedList<Expression>(); :}
;
thisExpr ::= THIS:t
			{: RESULT = new This(getLine()); :}
;
newClassNewExpr ::= NEW CLASS_ID:cid LPAREN RPAREN
				{: RESULT = new NewClass(getLine(), cid); :}
;
newArrayNewExpr ::= NEW type:pt LB expr:e RB
				{: RESULT = new NewArray(pt, e); :}
;
lengthExpr ::= expr:e DOT LENGTH
			{: RESULT = new Length(e); :}
;
binaryOpExpr ::= logicalBinaryOpBinop:lbop
			{: RESULT = lbop; :}
			| mathBinaryOpBinop:mbop
			{: RESULT = mbop; :}
;
logicalBinaryOpBinop ::= expr:e1 logicalBinop:lbop expr:e2
					{: RESULT = new LogicalBinaryOp(e1, lbop, e2); :}
;
mathBinaryOpBinop ::= expr:e1 mathBinop:mbop expr:e2
					{: RESULT = new MathBinaryOp(e1, mbop, e2); :}
;
logicalBinop ::= LAND
		{: RESULT = BinaryOps.LAND; :}
		| LOR
		{: RESULT = BinaryOps.LOR; :}
		| LTE
		{: RESULT = BinaryOps.LTE; :}
		| GTE
		{: RESULT = BinaryOps.GTE; :}
		| LT
		{: RESULT = BinaryOps.LT; :}
		| GT
		{: RESULT = BinaryOps.GT; :}
		| EQUAL
		{: RESULT = BinaryOps.EQUAL; :}
		| NEQUAL
		{: RESULT = BinaryOps.NEQUAL; :}
;		
mathBinop ::= PLUS
			{: RESULT = BinaryOps.PLUS; :}
			| MINUS
			{: RESULT = BinaryOps.MINUS; :}
			| MULTIPLY
			{: RESULT = BinaryOps.MULTIPLY; :}
			| DIVIDE
			{: RESULT = BinaryOps.DIVIDE; :}
			| MOD
			{: RESULT = BinaryOps.MOD; :}
;
unaryOpExpr ::= logicalUnaryOpUnop:luop
			{: RESULT = luop; :}
			| mathUnaryOpUnop:muop
			{: RESULT = muop; :}
;
logicalUnaryOpUnop ::= logicalUnop:luop expr:e
					{: RESULT = new LogicalUnaryOp(luop, e); :}
;
mathUnaryOpUnop	::=	mathUnop:muop expr:e
					{: RESULT = new MathUnaryOp(muop, e); :} %prec UMINUS //TODO correct only because math unary is only minus
;
logicalUnop ::= LNEG					
			{: RESULT = UnaryOps.LNEG; :}
;
mathUnop ::= MINUS
			{: RESULT = UnaryOps.UMINUS; :}
;			
literalExpr ::= literal:l
			{: RESULT = l; :}
;
literal ::= INTEGER:i
		{: 
			String afterRmZeroes = i.replaceFirst("^0+","");
			if (afterRmZeroes.equals("") || afterRmZeroes.equals(i))
			{ RESULT = new Literal(getLine(), LiteralTypes.INTEGER, i); }
			else { throw new SyntaxError(getLine(), getColumn(), "number other than zero should not start with leading zeroes"); }
		:}
		| STRING:s
		{: RESULT = new Literal(getLine(), LiteralTypes.STRING, s); :}
		| TRUE:t
		{: RESULT = new Literal(getLine(), LiteralTypes.TRUE); :}
		| FALSE:f
		{: RESULT = new Literal(getLine(), LiteralTypes.FALSE); :}
		| NULL:n
		{: RESULT = new Literal(getLine(), LiteralTypes.NULL); :}
;		
expressionBlockExpr ::= LPAREN expr:e RPAREN
					{: RESULT = new ExpressionBlock(e); :}
;
